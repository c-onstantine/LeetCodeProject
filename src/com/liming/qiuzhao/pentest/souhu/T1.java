package com.liming.qiuzhao.pentest.souhu;

/**
 * @author ltf
 * @date 2022-09-03 19:02
 */
public class T1 {
    public final int[][] arr;

    public T1(int[][] arr) {
        this.arr = arr;
    }

    public static void main(String[] args) {
        int[][] arr = new int[][]{
                {0, 0, 0},
                {1, 1, 1},
                {0, 0, 0}
        };

        final T1 showMeBug = new T1(arr);

        showMeBug.updateNextState(arr);
        System.out.println(1);
    }

    /**
     * 更新arr下个tick的生存状态
     *
     * @param arr 当前状态下的数组
     */
    public void updateNextState(int[][] arr) {
        int M = arr.length;
        int N = arr[0].length;
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                arr[i][j] = getNextVal(arr, i, j);
            }
        }
    }

    /**
     * 计算某细胞下个tick的状态
     *
     * @param arr 当前状态下的数组
     * @param i   行索引
     * @param j   列索引
     * @return 生存返回1，否则返回0
     */
    private int getNextVal(int[][] arr, int i, int j) {
        int nextVal = 0;
        //TODO:请完善该函数，要求：需要调用countLivingNeighbors
        int count = countLivingNeighbors(arr,i,j);
        if(arr[i][j] == 1){
            if(count < 2){
                nextVal = 0;
            }else if(count == 2 || count ==3){
                nextVal = 1;
            }else if(count > 3){
                nextVal = 0;
            }
        }else{
            if(count == 3){
                nextVal = 1;
            }
        }
        return nextVal;
    }

    /**
     * 计算某细胞的存活邻居数量
     *
     * @param arr 当前状态下的数组
     * @param i   行索引
     * @param j   列索引
     * @return 该元素存活的邻居数量
     */
    private int countLivingNeighbors(int[][] arr, int i, int j) {
        int count = 0;
        //TODO:请完善该函数
        int [] dirx = new int[]{-1,-1,-1,0,0,1,1,1};
        int [] diry = new int[]{-1,0,1,-1,1,-1,0,1};
        for(int k = 0; k < 8; k++){
            int curx = i + dirx[k];
            int cury = j + diry[k];
            if(curx >= 0 && curx < arr.length && cury >=0 && cury < arr[0].length && arr[curx][cury] == 1){
                count++;
            }
        }
        return count;
    }
}
